// generated by JSDOC

declare module "canvacard" {
    import Canvas from 'canvas'
    import { Greeting } from 'discord-canvascard'
    /**
    * <p><strong>⚠ ¡No puede crear una instancia de la clase Canvacard! ⚠</strong></p>
    * @example
    * const Canvacard = require("canvacard");
  
    Canvacard.Canvas.trigger("./image.png")
    .then(triggered => {
        Canvacard.write(triggered, "triggered.gif");
    })
    */
    export class Canvacard {
        /**
         * <p>Este método se puede utilizar para aplicar el efecto Disparado en la imagen.</p>
         * @param image - <p>Imagen para activar</p>
         */
        static trigger(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Invierte el color de la imagen</p>
         * @param image - <p>Imagen para invertir</p>
         */
        static invert(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Aplicar lavado sepia en imagen</p>
         * @param image - <p>Imagen</p>
         */
        static sepia(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Efecto de escala de grises sobre la imagen</p>
         * @param image - <p>Imagen</p>
         */
        static greyscale(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Editar el brillo de la imagen</p>
         * @param image - <p>Imagen</p>
         * @param amount - <p>Cantidad de brillo</p>
         */
        static brightness(image: string | Buffer, amount: number): Promise<Buffer>;
        /**
         * <p>Editar la oscuridad de la imagen</p>
         * @param image - <p>Imagen</p>
         * @param amount - <p>Cantidad de oscuridad</p>
         */
        static darkness(image: string | Buffer, amount: number): Promise<Buffer>;
        /**
         * <p>Umbral de imagen</p>
         * @param img - <p>Image</p>
         * @param amount - <p>Cantidad límite</p>
         */
        static threshold(img: string | Buffer, amount: number): Promise<Buffer>;
        /**
         * <p>Convolución de la imagen</p>
         * @param img - <p>Imagen</p>
         * @param matrix - <p>Matriz de convolución</p>
         * @param opaque - <p>Si la convolución debe ser opaca</p>
         */
        static convolute(img: string | Buffer, matrix: number[], opaque: boolean): Promise<Buffer>;
        /**
         * <p>Crea barra de progreso</p>
         * @param track - <p>Opciones de pista de la barra de progreso</p>
         * @param [track.x] - <p>El eje x</p>
         * @param [track.y] - <p>El eje y</p>
         * @param [track.width] - <p>Ancho de pista de la barra de progreso</p>
         * @param [track.height] - <p>Altura de la pista de la barra de progreso</p>
         * @param [track.color] - <p>Color de la pista de la barra de progreso</p>
         * @param [track.stroke] - <p>Usar trazo para pista</p>
         * @param [track.lineWidth] - <p>Este parámetro se utilizará si <code>track.stroke</code> se establece en <code>true</code></p>
         * @param bar - <p>Opciones de la barra de progreso</p>
         * @param [bar.width] - <p>Ancho de la barra de progreso</p>
         * @param [bar.color] - <p>Color de la barra de progreso</p>
         */
        static createProgressBar(track: {
            x?: number;
            y?: number;
            width?: number;
            height?: number;
            color?: string;
            stroke?: boolean;
            lineWidth?: number;
        }, bar: {
            width?: number;
            color?: string;
        }): Buffer;
        /**
         * <p>Desenfocar una imagen</p>
         * @param image - <p>Imagen para difuminar</p>
         */
        static blur(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Pixelar</p>
         * @param image - <p>Imagen para pixelar</p>
         * @param pixels - <p>Pixeles</p>
         */
        static pixelate(image: string | Buffer, pixels?: number): Promise<Buffer>;
        /**
         * <p>Agudizar una imagen</p>
         * @param image - <p>Imagen para enfocar</p>
         * @param lvl - <p>intensidad de la nitidez</p>
         */
        static sharpen(image: string | Buffer, lvl?: number): Promise<Buffer>;
        /**
         * <p>Aplica efecto de quemado en una imagen.</p>
         * @param image - <p>Fuente de imagen</p>
         * @param lvl - <p>intensidad</p>
         */
        static burn(image: string | Buffer, lvl?: number): Promise<Buffer>;
        /**
         * <p>HTML5 color a imagen</p>
         * @param color - <p>Color HTML5</p>
         * @param displayHex - <p>Si debe mostrar hexadecimal</p>
         * @param height - <p>Altura de imagen</p>
         * @param width - <p>Ancho de la imagen</p>
         */
        static color(color?: string, displayHex?: boolean, height?: number, width?: number): Buffer;
        /**
         * <p>Crea una imagen circular</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static circle(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Crea un rectángulo</p>
         * @param x - <p>eje x</p>
         * @param y - <p>eje y</p>
         * @param width - <p>ancho</p>
         * @param height - <p>altura</p>
         * @param color - <p>color</p>
         * @param stroke - <p>Si debe acariciar</p>
         * @param lineWidth - <p>ancho de línea</p>
         */
        static rectangle(x: number, y: number, width: number, height: number, color: string, stroke: boolean, lineWidth: number): Buffer;
        /**
         * <p>Imágenes de fusion two</p>
         * @param image1 - <p>Primera imagen</p>
         * @param image2 - <p>Segunda imagen</p>
         */
        static fuse(image1: string | Buffer, image2: string | Buffer): Promise<Buffer>;
        /**
         * <p>Cambiar el tamaño de una imagen</p>
         * @param image - <p>Fuente de imagen</p>
         * @param width - <p>ancho</p>
         * @param height - <p>altura</p>
         */
        static resize(image: string | Buffer, width: number, height: number): Promise<Buffer>;
        /**
         * <p>Besarse ( ͡° ͜ʖ ͡°)</p>
         * @param image1 - <p>Primera imagen</p>
         * @param image2 - <p>Segunda imagen</p>
         */
        static kiss(image1: string | Buffer, image2: string | Buffer): Promise<Buffer>;
        /**
         * <p>Azotar a alguien ( ͡° ͜ʖ ͡°)</p>
         * @param image1 - <p>Primera imagen</p>
         * @param image2 - <p>Segunda imagen</p>
         */
        static spank(image1: string | Buffer, image2: string | Buffer): Promise<Buffer>;
        /**
         * <p>Cargar fuentes</p>
         * @param fontArray - <p>Matriz de fuentes</p>
         */
        static registerFonts(fontArray: any[]): Promise<void>;
        /**
         * <p>Abofetear a alguien ( ͡° ͜ʖ ͡°)</p>
         * @param image1 - <p>Primera imagen</p>
         * @param image2 - <p>Segunda imagen</p>
         */
        static slap(image1: string | Buffer, image2: string | Buffer): Promise<Buffer>;
        /**
         * <p>¿Oh esto? ¡Esto es hermoso!</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static beautiful(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>facepalm</p>
         * @param image - <p>imagen</p>
         */
        static facepalm(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Rainbow ( ͡° ͜ʖ ͡°)</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static rainbow(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>&quot;F&quot; en el chat</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static rip(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>¿Basura?</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static trash(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Peor que hitler</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static hitler(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Actualiza el color de la imagen</p>
         * @param image - <p>Fuente de imagen</p>
         * @param color - <p>Color HTML5</p>
         */
        static colorfy(image: string | Buffer, color: string): Promise<Buffer>;
        /**
         * <p>whoosh</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static jokeOverHead(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Novio distraído</p>
         * @param image1 - <p>Rostro para la niña en color rojo.</p>
         * @param image2 - <p>Cara para el chico</p>
         * @param image3 - <p>Cara para la otra chica [opcional]</p>
         */
        static distracted(image1: string | Buffer, image2: string | Buffer, image3: string | Buffer): Promise<Buffer>;
        /**
         * <p>No, no afecta a mi bebé.</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static affect(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Celda</p>
         * @param image - <p>Fuente de imagen</p>
         * @param greyscale - <p>Si debe ser una imagen en escala de grises</p>
         */
        static jail(image: string | Buffer, greyscale: boolean): Promise<Buffer>;
        /**
         * <p>cama</p>
         * @param image1 - <p>Primera imagen</p>
         * @param image2 - <p>Segunda imagen</p>
         */
        static bed(image1: string | Buffer, image2: string | Buffer): Promise<Buffer>;
        /**
         * <p>Borrar</p>
         * @param image - <p>Fuente de imagen</p>
         * @param dark - <p>Si la imagen debe estar en modo oscuro</p>
         */
        static delete(image: string | Buffer, dark: boolean): Promise<Buffer>;
        /**
         * <p>TicTacToe</p>
         * @param fill - <p>TicTacToe params</p>
         * @param [fill.a1] - <p>valor a1</p>
         * @param [fill.b1] - <p>valor b1</p>
         * @param [fill.c1] - <p>valor c1</p>
         * @param [fill.a2] - <p>valor a2</p>
         * @param [fill.b2] - <p>valor b2</p>
         * @param [fill.c2] - <p>valor c2</p>
         * @param [fill.a3] - <p>valor a3</p>
         * @param [fill.b3] - <p>valor b3</p>
         * @param [fill.c3] - <p>valor c3</p>
         * @param color - <p>Parámetros de color</p>
         * @param [color.bg] - <p>Color de fondo</p>
         * @param [color.bar] - <p>Color de la barra TicTacToe</p>
         * @param [color.x] - <p>Color de <strong>X</strong></p>
         * @param [color.o] - <p>Color de <strong>O</strong></p>
         */
        static tictactoe(fill: {
            a1?: "X" | "O";
            b1?: "X" | "O";
            c1?: "X" | "O";
            a2?: "X" | "O";
            b2?: "X" | "O";
            c2?: "X" | "O";
            a3?: "X" | "O";
            b3?: "X" | "O";
            c3?: "X" | "O";
        }, color: {
            bg?: string;
            bar?: string;
            x?: string;
            o?: string;
        }): Buffer;
        /**
         * <p>Opinión</p>
         * @param avatar - <p>Imagen</p>
         * @param msg - <p>Mensaje</p>
         */
        static opinion(avatar: string | Buffer, msg: string): Promise<Buffer>;
        /**
         * <p>Crea degradado</p>
         * @param colorFrom - <p>Color inicial</p>
         * @param colorTo - <p>Color final</p>
         * @param width - <p>Ancho de la imagen</p>
         * @param height - <p>Altura de imagen</p>
         */
        static gradient(colorFrom: string, colorTo: string, width: number, height: number): Buffer;
        /**
         * <p>¡Oh, no! Es estúpido.</p>
         * @param message - <p>Mensaje</p>
         */
        static ohno(message: string): Promise<Buffer>;
        /**
         * <p>Cambiar de opinión (tomado de jgoralcz / image-microservice)</p>
         * @param text - <p>Texto</p>
         */
        static changemymind(text: string): Promise<Buffer>;
        /**
         * <p>Clyde</p>
         * @param message - <p>Mensaje</p>
         */
        static clyde(message: string): Promise<Buffer>;
        /**
         * <p>Cita falsa</p>
         * @param options - <p>Options</p>
         * @param [options.image] - <p>Imagen</p>
         * @param [options.message] - <p>Mensaje</p>
         * @param [options.username] - <p>Nombre de usuario</p>
         * @param [options.color] - <p>Color</p>
         */
        static quote(options: {
            image?: Buffer | string;
            message?: string;
            username?: string;
            color?: string;
        }): Promise<Buffer>;
        /**
         * <p>Comentario de PornHub</p>
         * @param options - <p>Opciones</p>
         * @param [options.username] - <p>Nombre de usuario</p>
         * @param [options.message] - <p>Comentario</p>
         * @param [options.image] - <p>Imagen</p>
         */
        static phub(options: {
            username?: string;
            message?: string;
            image?: string | Buffer;
        }): Promise<Buffer>;
        /**
         * <p>Wanted</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static wanted(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Wasted</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static wasted(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Comentario de YouTube</p>
         * @param ops - <p>Opciones de comentarios de YouTube</p>
         * @param [ops.username] - <p>Nombre de usuario del autor del comentario</p>
         * @param [ops.content] - <p>El comentario</p>
         * @param [ops.avatar] - <p>Fuente de avatar</p>
         * @param [ops.dark = false] - <p>¿Modo oscuro?</p>
         */
        static youtube(ops: {
            username?: string;
            content?: string;
            avatar?: string | Buffer;
            dark?: boolean;
        }): Promise<Buffer>;
        /**
         * <p>¡Oh, mierda!</p>
         * @param image - <p>Fuente de imagen</p>
         */
        static shit(image: string | Buffer): Promise<Buffer>;
        /**
         * <p>Escribe los datos como archivo</p>
         * @param data - <p>datos para escribir</p>
         * @param name - <p>nombre del archivo</p>
         */
        static write(data: Buffer, name: string): void;
        /**
         * <p>Devuelve el icono predeterminado de un servidor de discord</p>
         * @param name - <p>Nombre del servidor</p>
         * @param size - <p>Tamaño de ícono. Válido: <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>, <code>256</code>, <code>512</code>, <code>1024</code>, <code>2048</code> &amp; <code>4096</code></p>
         */
        static guildIcon(name: string, size?: number): Promise<Buffer>;
        /**
         * <p>Clon de respuesta de discord</p>
         * @example
         * const img = "https://cdn.discordapp.com/embed/avatars/0.png";
        const img2 = "https://cdn.discordapp.com/embed/avatars/4.png";
        canvacard.Canvas.reply({
            avatar1: img,
            avatar2: img2,
            user1: "Maximus",
            user2: "SrGobi",
            hex1: "#FF3300",
            hex2: "#7289da",
            mainText: "kok",
            replyText: "Pog"
        })
        .then(img => canvacard.write(img, "reply.png"));
        * @param options - <p>Opciones</p>
        * @param [options.avatar1] - <p>Avatar de la persona que respondió</p>
        * @param [options.avatar2] - <p>Avatar de la otra persona</p>
        * @param [options.user1] - <p>Nombre de usuario de la persona que respondió</p>
        * @param [options.user2] - <p>Nombre de usuario de la otra persona</p>
        * @param [options.hex1] - <p>Color hexadecimal de la persona que respondió</p>
        * @param [options.hex2] - <p>Color hexadecimal de la otra persona</p>
        * @param [options.mainText] - <p>El mensaje</p>
        * @param [options.replyText] - <p>El mensaje de respuesta</p>
        */
        static reply(options: {
            avatar1?: string | Buffer;
            avatar2?: string | Buffer;
            user1?: string;
            user2?: string;
            hex1?: string;
            hex2?: string;
            mainText?: string;
            replyText?: string;
        }): Promise<Buffer>;
        /**
         * <p>Método Canvacard utilizado para <code>wait</code>.</p>
         * @param dur - <p>Número de milisegundos a esperar</p>
         */
        static __wait(dur: number): Promise<void>;
        /**
         * <p>Datos de matriz para <strong>Canvacard.convolute()</strong></p>
         */
        static CONVOLUTION_MATRIX: ConvolutionMatrix;
        /**
         * <p>Utilidades de Canvacard</p>
         */
        static Util: Util;
    }

    /**
     * <p>Matriz de convolución Canvacard</p>
     * @property EDGES - <p>Matriz de bordes</p>
     * @property BLUR - <p>Matriz de desenfoque</p>
     * @property SHARPEN - <p>Matriz de afilado</p>
     * @property BURN - <p>Quemar matriz</p>
     */
    export type ConvolutionMatrix = {
        EDGES: number[];
        BLUR: number[];
        SHARPEN: number[];
        BURN: number[];
    };

    /**
     * <p>Crea una tarjeta de presencia de Spotify</p>
     * @example
     * const card = new canvacard.Spotify()
     *         .setAuthor("Indila")
     *         .setAlbum("Mini World")
     *         .setStartTimestamp(Date.now() - 10000)
     *         .setEndTimestamp(Date.now() + 50000)
     *         .setImage("https://is5-ssl.mzstatic.com/image/thumb/Features111/v4/a4/89/a1/a489a1cb-4543-6861-a276-4470d41d6a90/mzl.zcdmhnlk.jpg/800x800bb.jpeg")
     *         .setTitle("S.O.S");
     *
     *     card.build()
     *         .then(data => {
     *             canvacard.write(data, "./images/spotify.png");
     *         });
     */
    export class Spotify {
        /**
         * <p>Título de la canción</p>
         */
        title: string;
        /**
         * <p>Miniatura</p>
         */
        image: string | Buffer | Canvas.Image;
        /**
         * <p>Artista de la canción</p>
         */
        artist: string;
        /**
         * <p>Nombre del álbum de Spotify</p>
         */
        album: string;
        /**
         * <p>Marca de tiempo de inicio de presencia de discord</p>
         */
        start: number;
        /**
         * <p>Marca de tiempo de finalización de presencia de discord</p>
         */
        end: number;
        /**
         * <p>Fondo</p>
         */
        background: SpotifyDataBG;
        /**
         * <p>Detalles de la barra de progreso</p>
         */
        progressBar: SpotifyProgressBarData;
        /**
         * <p>Establecer detalles de la barra de progreso</p>
         * @param type - <p>Tipo de barra de progreso</p>
         * @param color - <p>Color a establecer</p>
         */
        setProgressBar(type: "TRACK" | "BAR", color: string): Spotify;
        /**
         * <p>Establecer título</p>
         * @param title - <p>Título para establecer</p>
         */
        setTitle(title: string): Spotify;
        /**
         * <p>Establecer imagen</p>
         * @param source - <p>Fuente de imagen</p>
         */
        setImage(source: string | Buffer | Canvas.Image): Spotify;
        /**
         * <p>Establecer nombre de artista</p>
         * @param name - <p>Nombre del artista</p>
         */
        setAuthor(name: string): Spotify;
        /**
         * <p>Establecer el nombre del álbum</p>
         * @param name - <p>Nombre del álbum</p>
         */
        setAlbum(name: string): Spotify;
        /**
         * <p>Establecer marca de tiempo de inicio</p>
         * @param time - <p>Marca de tiempo</p>
         */
        setStartTimestamp(time: Date | number): Spotify;
        /**
         * <p>Establecer marca de tiempo de finalización</p>
         * @param time - <p>Marca de tiempo</p>
         */
        setEndTimestamp(time: Date | number): Spotify;
        /**
         * <p>Definir fondo</p>
         * @param type - <p>Tipo de fondo</p>
         * @param data - <p>Datos de fondo</p>
         */
        setBackground(type?: "COLOR" | "IMAGE", data?: string | Buffer | Canvas.Image): Spotify;
        /**
         * <p>Esta función convierte los datos sin procesar en una tarjeta de presencia de Spotify.</p>
         */
        build(): Promise<Buffer>;
    }

    /**
     * @property type - <p>Tipo de fondo</p>
     * @property data - <p>Datos de fondo</p>
     */
    export type SpotifyDataBG = {
        type: number;
        data: string | Buffer;
    };

    /**
     * @property bgColor - <p>Progressbar bg color</p>
     * @property color - <p>Progressbar bg color</p>
     */
    export type SpotifyProgressBarData = {
        bgColor: string;
        color: string;
    };

    /**
     * <p>Creador de imágenes de bienvenida</p>
     * @example
     * const card = new canvacard.Welcomer()
     *             .setAvatar(`https://cdn.discordapp.com/embed/avatars/0.png`);
     *             .setBackground("COLOR", "#2c2f33" ||"IMAGE", `https://i.imgur.com/aClDVjh.jpg`);
     *             .setTitulo("Titulo personalizable!");
     *             .setSubtitulo("Subtitulo personalizable!");
     *             .setColorTitulo("#FFFFFF");
     *             .setColorSubtitulo("#5865f2");
     *             .setColorCircle("#FFFFFF");
     *             .setColorBorder("#000000");
     *             .setOpacityBorder("0.4");
     *             .setColor("border", "#4D5E94");
     *             .setColor("titulo", "#4D5E94");
     *             .setColor("subtitulo", "#4D5E94");
     *             .setColor("avatar", "#4D5E94");
     *         card.build()
     *             .then(data => {
     *                 canvacard.write(data, "welcomer.png");
     *             })
     */
    export class Welcomer {
        constructor();
        /**
         * <p>Título creado con Canvacard</p>
         */
        textTitle: string;
        /**
         * <p>Subtítulo creado con Canvacard</p>
         */
        textSubtitle: string;
        /**
         * <p>Mensaje de texto creado con Canvacard</p>
         */
        textMessage: string;
        /**
         * <p>Borde de opacidad creado con canvacard</p>
         */
        opacityBorder: string;
        /**
         * <p>Color de borde creado con canvacard</p>
         */
        colorBorder: string;
        /**
         * <p>Color de círculo creado con canvacard</p>
         */
        colorCircle: string;
        /**
         * <p>Color de subtítulo creado con canvacard</p>
         */
        colorSubtitle: string;
        /**
         * <p>Color de título creado con canvacard</p>
         */
        colorTitle: string;
        /**
         * <p>Establecer color</p>
         * @param color - <p>Código de color HTML5</p>
         */
        setColor(id: "title" | "title-border" | "avatar" | "username" | "username-box" | "hashtag" | "discriminator" | "discriminator-box" | "message" | "message-box" | "member-count" | "background" | "border", color: string): Welcomer;
        /**
         * <p>Establecer opacidad</p>
         * @param opacityBorder - <p>Código de opacidad HTML5</p>
         */
        setOpacityBorder(opacityBorder: string): Greeting;
        /**
         * <p>Establecer color</p>
         * @param colorBorder - <p>Código de color HTML5</p>
         */
        setColorBorder(colorBorder: string): Greeting;
        /**
         * <p>Establecer color</p>
         * @param colorCircle - <p>Código de color HTML5</p>
         */
        setColorCircle(colorCircle: string): Greeting;
        /**
         * <p>Establecer color</p>
         * @param colorSubtitle - <p>Código de color HTML5</p>
         */
        setColorSubtitulo(colorSubtitle: string): Greeting;
        /**
         * <p>Establecer color</p>
         * @param colorTitle - <p>Código de color HTML5</p>
         */
        setColorTitulo(colorTitle: string): Greeting;
        /**
         * <p>Recuento de miembros de ser</p>
         * @param memberCount - <p>Recuento de miembros del gremio</p>
         */
        setMemberCount(memberCount?: number | string): Welcomer;
        /**
         * <p>Establecer subtítulo</p>
         * @param textSubtitle - <p>Subtítulo para configurar</p>
         */
        setSubtitulo(textSubtitle: string): Greeting;
        /**
         * <p>Establecer título</p>
         * @param textTitle - <p>Título para establecer</p>
         */
        setTitulo(textTitle: string): Greeting;
        /**
         * <p>Establecer imagen / color de fondo</p>
         * @param type - <p>Tipo de fondo</p>
         * @param [data] - <p>Color o imagen de fondo</p>
         */
        setBackground(type: "COLOR" | "IMAGE", data?: string | Buffer): Greeting;
        /**
         * <p>Avatar de usuario</p>
         * @param data - <p>Datos de avatar</p>
         */
        setAvatar(data: string | Buffer): Greeting;
        /**
         * <p>Crea una imagen de bienvenida</p>
         */
        build(): Promise<Buffer>;
    }
    /**
     * <p>Generador de imágenes de abandono</p>
     * @example
     * const card = new canvacard.Leaver()
     *             .setAvatar(`https://cdn.discordapp.com/embed/avatars/0.png`);
     *             .setBackground("COLOR", "#2c2f33" ||"IMAGE", `https://i.imgur.com/aClDVjh.jpg`);
     *             .setTitulo("Titulo personalizable!");
     *             .setSubtitulo("Subtitulo personalizable!");
     *             .setColorTitulo("#FFFFFF");
     *             .setColorSubtitulo("#5865f2");
     *             .setColorCircle("#FFFFFF");
     *             .setColorBorder("#000000");
     *             .setOpacityBorder("0.4");
     *             .setColor("border", "#4D5E94");
     *             .setColor("titulo", "#4D5E94");
     *             .setColor("subtitulo", "#4D5E94");
     *             .setColor("avatar", "#4D5E94");
     *         card.build()
     *             .then(data => {
     *                 canvacard.write(data, "leaver.png");
     *             })
     */
    export class Leaver {
        constructor();
        /**
         * <p>Título creado con Canvacard</p>
         */
        textTitle: string;
         /**
          * <p>Subtítulo creado con Canvacard</p>
          */
        textSubtitle: string;
         /**
          * <p>Mensaje de texto creado con Canvacard</p>
          */
        textMessage: string;
         /**
          * <p>Borde de opacidad creado con canvacard</p>
          */
        opacityBorder: string;
         /**
          * <p>Color de borde creado con canvacard</p>
          */
        colorBorder: string;
         /**
          * <p>Color de círculo creado con canvacard</p>
          */
        colorCircle: string;
         /**
          * <p>Color de subtítulo creado con canvacard</p>
          */
        colorSubtitle: string;
         /**
          * <p>Color de título creado con canvacard</p>
          */
        colorTitle: string;
         /**
          * <p>Establecer color</p>
          * @param color - <p>Código de color HTML5</p>
          */
        setColor(id: "title" | "title-border" | "avatar" | "username" | "username-box" | "hashtag" | "discriminator" | "discriminator-box" | "message" | "message-box" | "member-count" | "background" | "border", color: string): Welcomer;
         /**
          * <p>Establecer opacidad</p>
          * @param opacityBorder - <p>Código de opacidad HTML5</p>
          */
        setOpacityBorder(opacityBorder: string): Greeting;
         /**
          * <p>Establecer color</p>
          * @param colorBorder - <p>Código de color HTML5</p>
          */
        setColorBorder(colorBorder: string): Greeting;
         /**
          * <p>Establecer color</p>
          * @param colorCircle - <p>Código de color HTML5</p>
          */
        setColorCircle(colorCircle: string): Greeting;
         /**
          * <p>Establecer color</p>
          * @param colorSubtitle - <p>Código de color HTML5</p>
          */
        setColorSubtitulo(colorSubtitle: string): Greeting;
         /**
          * <p>Establecer color</p>
          * @param colorTitle - <p>Código de color HTML5</p>
          */
        setColorTitulo(colorTitle: string): Greeting;
         /**
          * <p>Recuento de miembros de ser</p>
          * @param memberCount - <p>Recuento de miembros del gremio</p>
          */
        setMemberCount(memberCount?: number | string): Welcomer;
         /**
          * <p>Establecer subtítulo</p>
          * @param textSubtitle - <p>Subtítulo para configurar</p>
          */
        setSubtitulo(textSubtitle: string): Greeting;
         /**
          * <p>Establecer título</p>
          * @param textTitle - <p>Título para establecer</p>
          */
        setTitulo(textTitle: string): Greeting;
         /**
          * <p>Establecer imagen / color de fondo</p>
          * @param type - <p>Tipo de fondo</p>
          * @param [data] - <p>Color o imagen de fondo</p>
          */
        setBackground(type: "COLOR" | "IMAGE", data?: string | Buffer): Greeting;
         /**
          * <p>Avatar de usuario</p>
          * @param data - <p>Datos de avatar</p>
          */
        setAvatar(data: string | Buffer): Greeting;
         /**
          * <p>Crea una imagen de abandono</p>
          */
        build(ops: {
            fontX?: string;
            fontY?: string;
        }): Promise<Buffer>;
    }

    /**
     * @property circle - <p>Complemento de círculo</p>
     * @property convolute - <p>Complemento convolute</p>
     * @property rectangle - <p>Complemento de rectángulo</p>
     * @property round - <p>Complemento redondo</p>
     * @property abbrev - <p>Complemento de abreviaturas</p>
     * @property renderEmoji - <p>Complemento de renderizado de emoji</p>
     */
    export type Plugins = {
        circle: (...params: any[]) => any;
        convolute: (...params: any[]) => any;
        rectangle: (...params: any[]) => any;
        round: (...params: any[]) => any;
        abbrev: (...params: any[]) => any;
        renderEmoji: (...params: any[]) => any;
    };

    /**
     * @property width - <p>Ancho de la tarjeta de rango</p>
     * @property height - <p>Altura de la tarjeta de rango</p>
     * @property background - <p>Datos de antecedentes de la tarjeta de rango</p>
     * @property [background.type = "color"] - <p>Tipo de fondo</p>
     * @property [background.image = "#23272A"] - <p>Imagen de fondo (o color)</p>
     * @property progressBar - <p>Datos de la barra de progreso</p>
     * @property [progressBar.rounded = true] - <p>Si la barra de progreso debe redondearse</p>
     * @property [progressBar.x = 275.5] - <p>Barra de progreso X</p>
     * @property [progressBar.y = 183.75] - <p>Barra de progreso Y</p>
     * @property [progressBar.height = 37.5] - <p>Altura de la barra de progreso</p>
     * @property [progressBar.width = 596.5] - <p>Ancho de la barra de progreso</p>
     * @property [progressBar.track] - <p>Pista de la barra de progreso</p>
     * @property [progressBar.track.color = "#484b4E"] - <p>Color de la pista de la barra de progreso</p>
     * @property [progressBar.bar] - <p>Datos de la barra de progreso</p>
     * @property [progressBar.bar.type = "color"] - <p>Tipo de barra de progreso</p>
     * @property [progressBar.bar.color = "#FFFFFF"] - <p>Color de la barra de progreso</p>
     * @property overlay - <p>Superposición de la barra de progreso</p>
     * @property [overlay.display = true] - <p>Si debería mostrar superposición</p>
     * @property [overlay.level = 0.5] - <p>Nivel de opacidad de superposición</p>
     * @property [overlay.color = "#333640"] - <p>Color de fondo de superposición</p>
     * @property avatar - <p>Datos de avatar de la tarjeta de rango</p>
     * @property [avatar.source = null] - <p>Fuente de avatar</p>
     * @property [avatar.x = 70] - <p>X</p>
     * @property [avatar.y = 50] - <p>Y</p>
     * @property [avatar.height = 180] - <p>altura</p>
     * @property [avatar.width = 180] - <p>ancho</p>
     * @property status - <p>Estado de la tarjeta de rango</p>
     * @property [status.width = 5] - <p>Ancho de estado</p>
     * @property [status.type] - <p>Tipo de estado</p>
     * @property [status.color = "#43B581"] - <p>Color de estado</p>
     * @property [status.circle = false] - <p>¿Estado de Circualr?</p>
     * @property rank - <p>Datos de rango de la tarjeta de clasificación</p>
     * @property [rank.display = true] - <p>Si debería mostrar rango</p>
     * @property [rank.data = 1] - <p>El rango</p>
     * @property [rank.textColor = "#FFFFFF"] - <p>Rango de color del texto</p>
     * @property [rank.color = "#F3F3F3"] - <p>Color de rango</p>
     * @property [rank.displayText = "RANK"] - <p>Texto de visualización de rango</p>
     * @property level - <p>Datos de nivel de tarjeta de rango</p>
     * @property [level.display = true] - <p>Si debería mostrar el nivel</p>
     * @property [level.data = 1] - <p>El nivel</p>
     * @property [level.textColor = "#FFFFFF"] - <p>color de texto de nivel</p>
     * @property [level.color = "#F3F3F3"] - <p>color de nivel</p>
     * @property [level.displayText = "LEVEL"] - <p>texto de visualización de nivel</p>
     * @property currentXP - <p>Tarjeta de rango xp actual</p>
     * @property [currentXP.data = 0] - <p>XP actual</p>
     * @property [currentXP.color = "#FFFFFF"] - <p>Carta de rango color xp actual</p>
     * @property requiredXP - <p>Tarjeta de rango requerida xp</p>
     * @property [requiredXP.data = 0] - <p>requerido xp</p>
     * @property [requiredXP.color = "#FFFFFF"] - <p>Se requiere tarjeta de rango xp color</p>
     * @property discriminator - <p>Discriminador de cartas de rango</p>
     * @property [discriminator.discrim = null] - <p>El discriminador</p>
     * @property [discriminator.color = "rgba(255, 255, 255, 0.4)"] - <p>Color del discriminador de la tarjeta de rango</p>
     * @property username - <p>Datos de nombre de usuario</p>
     * @property [username.name = null] - <p>Nombre de usuario de la tarjeta de clasificación</p>
     * @property [username.color = "#FFFFFF"] - <p>Color de nombre de usuario de la tarjeta de rango</p>
     * @property [renderEmojis = false] - <p>Si debería renderizar emojis</p>
     */
    export type CanvacardRankData = {
        width: number;
        height: number;
        background: {
            type?: "gif" | "image" | "color";
            image?: string | Buffer;
        };
        progressBar: {
            rounded?: boolean;
            x?: number;
            y?: number;
            height?: number;
            width?: number;
            track?: {
                color?: string;
            };
            bar?: {
                type?: "color" | "gradient";
                color?: string | string[];
            };
        };
        overlay: {
            display?: boolean;
            level?: number;
            color?: string;
        };
        avatar: {
            source?: string | Buffer;
            x?: number;
            y?: number;
            height?: number;
            width?: number;
        };
        status: {
            width?: number;
            type?: "online" | "dnd" | "idle" | "offline" | "streaming";
            color?: string;
            circle?: boolean;
        };
        rank: {
            display?: boolean;
            data?: number;
            textColor?: string;
            color?: string;
            displayText?: string;
        };
        level: {
            display?: boolean;
            data?: number;
            textColor?: string;
            color?: string;
            displayText?: string;
        };
        currentXP: {
            data?: number;
            color?: string;
        };
        requiredXP: {
            data?: number;
            color?: string;
        };
        discriminator: {
            discrim?: number | string;
            color?: string;
        };
        username: {
            name?: string;
            color?: string;
        };
        renderEmojis?: boolean;
    };

    /**
     * <p>Crea una carta de rango</p>
     * @example
     * const rank = new canvacard.Rank()
     *             .setAvatar(img)
     *             .setCurrentXP(203)
     *             .setRequiredXP(500)
     *             .setStatus("dnd")
     *             .setProgressBar(["#FF0000", "#0000FF"], "GRADIENT")
     *             .setUsername("SrGobi")
     *             .setDiscriminator("0001");
     *
     *         rank.build()
     *             .then(data => {
     *                 canvacard.write(data, "RankCard.png");
     *             })
     */
    export class Rank {
        constructor();
        /**
         * <p>Datos de la tarjeta de clasificación</p>
         */
        data: CanvacardRankData;
        /**
         * <p>Cargar fuentes</p>
         * @param fontArray - <p>Matriz de fuentes</p>
         */
        registerFonts(fontArray: any[]): Rank;
        /**
         * <p>Si debe representar el nombre de usuario con emojis (si corresponde)</p>
         * @param [apply = false] - <p>Ponlo en <code>true</code> para renderizar emojis.</p>
         */
        renderEmojis(apply?: boolean): Rank;
        /**
         * <p>Establecer nombre de usuario</p>
         * @param name - <p>Nombre de usuario</p>
         * @param color - <p>Color del nombre de usuario</p>
         */
        setUsername(name: string, color?: string): Rank;
        /**
         * <p>Establecer discriminador</p>
         * @param discriminator - <p>Discriminador de usuario</p>
         * @param color - <p>Color discriminador</p>
         */
        setDiscriminator(discriminator: string | number, color?: string): Rank;
        /**
         * <p>Establecer el estilo de la barra de progreso</p>
         * @param color - <p>Color de la barra de progreso</p>
         * @param [fillType = COLOR] - <p>Tipo de barra de progreso</p>
         * @param [rounded = true] - <p>Si la barra de progreso debe tener bordes redondeados</p>
         */
        setProgressBar(color: string | string[], fillType?: "COLOR" | "GRADIENT", rounded?: boolean): Rank;
        /**
         * <p>Establecer pista de la barra de progreso</p>
         * @param color - <p>Color de la pista</p>
         */
        setProgressBarTrack(color: string): Rank;
        /**
         * <p>Establecer superposición de tarjetas</p>
         * @param color - <p>Color de superposición</p>
         * @param [level = 0.5] - <p>Nivel de opacidad</p>
         * @param [display = true] - <p>SI debería mostrar superposición</p>
         */
        setOverlay(color: string, level?: number, display?: boolean): Rank;
        /**
         * <p>Establecer xp requerido</p>
         * @param data - <p>Requerido xp</p>
         * @param color - <p>Color</p>
         */
        setRequiredXP(data: number, color?: string): Rank;
        /**
         * <p>Establecer xp actual</p>
         * @param data - <p>XP actual</p>
         * @param color - <p>Color</p>
         */
        setCurrentXP(data: number, color?: string): Rank;
        /**
         * <p>Establecer rango</p>
         * @param data - <p>Posición actual</p>
         * @param text - <p>Mostrar texto</p>
         * @param [display = true] - <p>Si debería mostrar rango</p>
         */
        setRank(data: number, text?: string, display?: boolean): Rank;
        /**
         * <p>Establecer color de visualización de rango</p>
         * @param text - <p>color de texto</p>
         * @param number - <p>Color del número</p>
         */
        setRankColor(text?: string, number?: string): Rank;
        /**
         * <p>Establecer color de nivel</p>
         * @param text - <p>color de texto</p>
         * @param number - <p>color del número</p>
         */
        setLevelColor(text?: string, number?: string): Rank;
        /**
         * <p>Establecer nivel</p>
         * @param data - <p>Nivel actual</p>
         * @param text - <p>Mostrar texto</p>
         * @param [display = true] - <p>Si debería mostrar el nivel</p>
         */
        setLevel(data: number, text?: string, display?: boolean): Rank;
        /**
         * <p>Establecer color de estado personalizado</p>
         * @param color - <p>Color a establecer</p>
         */
        setCustomStatusColor(color: string): Rank;
        /**
         * <p>Establecer estado</p>
         * @param status - <p>Estatus de usuario</p>
         * @param circle - <p>Si el icono de estado debe ser circular.</p>
         * @param width - <p>Ancho de estado</p>
         */
        setStatus(status: "online" | "idle" | "dnd" | "offline" | "streaming", circle: boolean, width?: number | boolean): Rank;
        /**
         * <p>Establecer imagen / color de fondo</p>
         * @param type - <p>Tipo de fondo</p>
         * @param [data] - <p>Color o imagen de fondo</p>
         */
        setBackground(type: "COLOR" | "IMAGE" | "GIF", data?: string | Buffer): Rank;
        /**
         * <p>Avatar de usuario</p>
         * @param data - <p>Datos de avatar</p>
         */
        setAvatar(data: string | Buffer): Rank;
        /**
         * <p>Construye carta de rango</p>
         * @param ops - <p>Fuentes</p>
         * @param [ops.fontX = "Manrope"] - <p>Familia tipográfica Bold</p>
         * @param [ops.fontY = "Manrope"] - <p>Familia tipográfica regular</p>
         */
        build(ops: {
            fontX?: string;
            fontY?: string;
        }): Promise<Buffer>;
    }

    /**
     * <p>Canvacard Util</p>
     */
    export class Util {
        constructor();
        /**
         * <p>Valida hexadecimal</p>
         * @param hex - <p>Código hexadecimal para validar</p>
         */
        static validateHex(hex: string): boolean;
        /**
         * <p>Convierte la marca de tiempo regular en discordia como el tiempo</p>
         * @param time - <p>Marca de tiempo para convertir</p>
         */
        static discordTime(time: Date | number): string;
        /**
         * <p>Formatea la hora</p>
         * @param time - <p>Hora de formatear</p>
         */
        static formatTime(time: number): string;
        /**
         * <p>Acortar el texto.</p>
         * @param text - <p>Texto para acortar</p>
         * @param len - <p>Longitud máxima</p>
         */
        static shorten(text: string, len: number): string;
        /**
         * <p>Convierte números en unidades como <code>1K</code>, <code>1M</code>, <code>1B</code> etc.</p>
         */
        static toAbbrev(num: number | string): void;
        /**
         * <p>Renderiza texto con emoji</p>
         * @param ctx - <p>CanvasRenderingContext2D</p>
         * @param msg - <p>Mensaje</p>
         * @param x - <p>X</p>
         * @param y - <p>Y</p>
         */
        static renderEmoji(ctx: CanvasRenderingContext2D, msg: string, x: number, y: number): Promise<void>;
        /**
         * <p>Devuelve código hexadecimal con formato</p>
         * @param hex - <p>Código hexadecimal para formatear</p>
         * @param alt - <p>Color alternativo</p>
         */
        static formatHex(hex: string, alt?: string): string;
        /**
         * <p>Invierte el color hexadecimal</p>
         * @param hex - <p>Código de color hexadecimal para invertir</p>
         */
        static invertColor(hex: string): string;
        /**
         * <p>Devuelve el acrónimo</p>
         * @param name - <p>Nombre para analizar el acrónimo</p>
         */
        static getAcronym(name: string): string;
        /**
         * <p>Devuelve una matriz de líneas</p>
         * @param params - <p>Parámetros</p>
         * @param text - <p>Texto</p>
         * @param ctx - <p>CanvasRenderingContext2D</p>
         * @param maxWidth - <p>Anchura máxima</p>
         */
        static getLines(params: any, text: string, ctx: CanvasRenderingContext2D, maxWidth: number): string[];
    }
}